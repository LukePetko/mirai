defmodule Mix.Tasks.Gen.Entities do
  @moduledoc """
  Fetches entities from Home Assistant and generates type definitions.
  
  Usage:
      mix gen.entities
      
  Requires HA_HOST and HA_TOKEN environment variables to be set.
  """
  use Mix.Task
  require Logger

  @shortdoc "Generate entity type definitions from Home Assistant"

  def run(_args) do
    # Start required applications
    Application.ensure_all_started(:gun)
    Application.ensure_all_started(:jason)

    host = System.get_env("HA_HOST", "homeassistant.local") |> String.to_charlist()
    port = String.to_integer(System.get_env("HA_PORT", "8123"))
    token = System.get_env("HA_TOKEN")

    if is_nil(token) do
      Mix.raise("HA_TOKEN environment variable is required")
    end

    Logger.info("Connecting to Home Assistant at #{host}:#{port}...")
    
    entities = fetch_entities(host, port, token)
    
    Logger.info("Found #{length(entities)} entities")
    
    output_path = generate_module(entities)
    
    Logger.info("Generated: #{output_path}")
    Mix.shell().info("\nâœ“ Entity definitions generated successfully!")
    Mix.shell().info("  File: #{output_path}")
    Mix.shell().info("  Run 'mix compile' to make them available to your editor")
  end

  defp fetch_entities(host, port, token) do
    # Open HTTP/2 connection
    {:ok, conn} = :gun.open(host, port, %{protocols: [:http]})
    {:ok, :http} = :gun.await_up(conn)

    # Make GET request to /api/states
    stream = :gun.get(conn, "/api/states", [
      {"authorization", "Bearer #{token}"},
      {"content-type", "application/json"}
    ])

    # Wait for response
    case :gun.await(conn, stream) do
      {:response, :fin, _status, _headers} ->
        Mix.raise("Empty response from Home Assistant")

      {:response, :nofin, 200, _headers} ->
        {:ok, body} = :gun.await_body(conn, stream)
        :gun.close(conn)
        
        body
        |> Jason.decode!()
        |> Enum.map(& &1["entity_id"])
        |> Enum.sort()

      {:response, :nofin, status, _headers} ->
        Mix.raise("HTTP #{status} from Home Assistant")
    end
  end

  defp generate_module(entities) do
    # Group entities by domain for better organization
    entities_by_domain = Enum.group_by(entities, fn entity_id ->
      [domain | _] = String.split(entity_id, ".")
      domain
    end)

    # Generate module in lib/ for compilation and autocomplete
    content = """
    defmodule Mirai.Entities do
      @moduledoc \"\"\"
      Entity definitions generated from Home Assistant.
      
      This file is generated by `mix gen.entities` and should be committed
      to version control. This allows your automations to have type checking
      and autocomplete without requiring a connection to Home Assistant.
      
      Generated at: #{DateTime.utc_now() |> DateTime.to_iso8601()}
      Total entities: #{length(entities)}
      
      ## Autocomplete
      
      Import this module in your automations to get function-based autocomplete:
      
          import Mirai.Entities
          
          def evening do
            turn_on(light_living_room())  # â† Autocomplete as you type!
          end
      
      \"\"\"

      # Base type for entity IDs (strings)
      @type entity_id :: String.t()
      
      # Domain-specific types (all are strings)
    #{generate_domain_types(entities_by_domain)}

      # All entities as a module attribute
      @entities #{inspect(entities, limit: :infinity)}

      @doc \"\"\"
      Returns all entity IDs.
      
      ## Example
      
          iex> Mirai.Entities.all()
          ["light.living_room", "switch.kitchen", ...]
      \"\"\"
      def all, do: @entities

      @doc \"\"\"
      Validates if an entity ID exists in Home Assistant.
      
      ## Example
      
          iex> Mirai.Entities.valid?("light.living_room")
          true
          
          iex> Mirai.Entities.valid?("light.nonexistent")
          false
      \"\"\"
      def valid?(entity_id), do: entity_id in @entities

      @doc \"\"\"
      Returns all entities for a given domain.
      
      ## Example
      
          iex> Mirai.Entities.by_domain("light")
          ["light.living_room", "light.bedroom", ...]
      \"\"\"
      def by_domain(domain) do
        Enum.filter(@entities, fn entity_id ->
          String.starts_with?(entity_id, "\#{domain}.")
        end)
      end

      @doc \"\"\"
      Returns all available domains.
      
      ## Example
      
          iex> Mirai.Entities.domains()
          ["light", "switch", "sensor", ...]
      \"\"\"
      def domains do
        @entities
        |> Enum.map(fn entity_id ->
          [domain | _] = String.split(entity_id, ".")
          domain
        end)
        |> Enum.uniq()
        |> Enum.sort()
      end
      
      # Domain helper functions
      #{generate_domain_helpers(entities_by_domain)}
      
      # Individual accessor functions for each entity (BEST AUTOCOMPLETE!)
      #{generate_entity_functions(entities)}
    end
    """

    File.mkdir_p!("lib/mirai/generated")
    output_path = "lib/mirai/generated/entities.ex"
    File.write!(output_path, content)
    
    output_path
  end

  defp generate_domain_types(entities_by_domain) do
    entities_by_domain
    |> Enum.sort_by(fn {domain, _} -> domain end)
    |> Enum.map(fn {domain, _entities} ->
      type_name = "#{domain}_entity"
      "  @type #{type_name} :: String.t()"
    end)
    |> Enum.join("\n")
  end
  
  defp generate_domain_helpers(entities_by_domain) do
    entities_by_domain
    |> Enum.sort_by(fn {domain, _} -> domain end)
    |> Enum.map(fn {domain, entities} ->
      """
        @doc \"\"\"
        Returns all #{domain} entities.
        \"\"\"
        def #{domain}_entities, do: #{inspect(entities, limit: :infinity)}
        
        @doc \"\"\"
        Checks if the given entity is a #{domain} entity.
        \"\"\"
        def #{domain}_entity?(entity_id), do: entity_id in #{inspect(entities, limit: :infinity)}
      """
    end)
    |> Enum.join("\n")
  end

  defp generate_entity_functions(entities) do
    entities
    |> Enum.map(fn entity_id ->
      # Convert "light.living_room" to "light_living_room"
      function_name = String.replace(entity_id, ".", "_")
      
      """
        @doc \"\"\"
        Returns the entity ID: #{entity_id}
        \"\"\"
        def #{function_name}(), do: "#{entity_id}"
      """
    end)
    |> Enum.join("\n")
  end
end
